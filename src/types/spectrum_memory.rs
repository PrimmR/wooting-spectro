use crate::MIN_DB;

const FLUTTER_DB_THRESHOLD: f32 = 2.;

/// Holds the state of Frequency-DB pairs to be displayed
/// A stateful counterpart to [crate::FreqIntensity] 
#[derive(Debug, Default, Clone)]
pub struct SpectrumMemory {
    pub weights: Vec<(f32, f32)>,
    pub decay: f32,
}

impl SpectrumMemory {
    /// Construct a new [SpectrumMemory]
    /// The frequencies attribute is intended to be generated by [crate::FreqIntensity::stateless_log_sections]
    pub fn new(frequencies: Vec<f32>, decay: f32) -> Self {
        let weights = frequencies.into_iter().map(|x| (x, MIN_DB)).collect();
        Self {
            weights,
            decay,
            // ..Default::default()
        }
    }

    /// Add a new frame of data to the state
    /// The weights attribute is intended to be generated by  [crate::FreqIntensity::log_sections]
    /// If an intensity for a particular frequency is higher than before, the new value will be taken on
    pub fn push(&mut self, weights: Vec<(f32, f32)>) {
        assert_eq!(
            self.weights.len(),
            weights.len(),
            "Incorrect length of weights pushed"
        );

        self.weights
            .iter_mut()
            .zip(weights.iter().chain(std::iter::repeat(&(0., MIN_DB))))
            .for_each(|(a, b)| {
                // Stop noise flutter
                a.1 = if (0.0..FLUTTER_DB_THRESHOLD).contains(&(b.1 - a.1))
                    && a.1 > MIN_DB + FLUTTER_DB_THRESHOLD
                {
                    a.1 + self.decay
                } else {
                    (a.1).max(b.1)
                }
            });
    }

    /// Apply the decay to the intensities of all frequencies
    pub fn tick(&mut self) {
        self.weights = self
            .weights
            .iter()
            .map(|x| (x.0, (x.1 - self.decay).max(MIN_DB)))
            .collect();
    }
}

impl PartialEq for SpectrumMemory {
    fn eq(&self, other: &Self) -> bool {
        self.weights == other.weights
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn new() {
        let mem = SpectrumMemory::new(vec![440.], 0.);

        assert_eq!(
            mem,
            SpectrumMemory {
                weights: vec![(440., MIN_DB)],
                ..Default::default()
            }
        )
    }

    #[test]
    fn ticking_down() {
        let mut mem = SpectrumMemory::new(vec![440.], 1.);
        mem.push(vec![(440., -14.)]);
        mem.tick();
        assert_eq!(
            mem,
            SpectrumMemory {
                weights: vec![(440., -15.)],
                ..Default::default()
            }
        )
    }

    #[test]
    fn ticking_min() {
        let mut mem = SpectrumMemory::new(vec![440.], 1.);
        let mem2 = mem.clone();
        mem.tick();
        assert_eq!(mem, mem2,)
    }

    #[test]
    fn push() {
        let mut mem = SpectrumMemory::new(vec![440.], 1.);
        mem.push(vec![(440., -1.)]);
        assert_eq!(
            mem,
            SpectrumMemory {
                weights: vec![(440., -1.)],
                ..Default::default()
            }
        )
    }
}
